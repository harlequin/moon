"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[31777],{43023:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(63696);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},89983:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"concepts/cache","title":"Cache","description":"moon\'s able to achieve high performance and blazing speeds by implementing a cache that\'s powered by","source":"@site/docs/concepts/cache.mdx","sourceDirName":"concepts","slug":"/concepts/cache","permalink":"/docs/concepts/cache","draft":false,"unlisted":false,"editUrl":"https://github.com/moonrepo/moon/tree/master/website/docs/concepts/cache.mdx","tags":[],"version":"current","frontMatter":{"title":"Cache"},"sidebar":"docs","previous":{"title":"Concepts","permalink":"/docs/concepts"},"next":{"title":"File groups","permalink":"/docs/concepts/file-group"}}');var i=t(62540),a=t(43023);const o={title:"Cache"},r=void 0,c={},h=[{value:"Hashing",id:"hashing",level:2},{value:"Archiving &amp; hydration",id:"archiving--hydration",level:2},{value:"File structure",id:"file-structure",level:2}];function l(e){const n={admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["moon's able to achieve high performance and blazing speeds by implementing a cache that's powered by\nour own unique smart hashing layer. All cache is stored in ",(0,i.jsx)(n.code,{children:".moon/cache"}),", relative from the\nworkspace root (be sure to git ignore this folder)."]}),"\n",(0,i.jsx)(n.h2,{id:"hashing",children:"Hashing"}),"\n",(0,i.jsx)(n.p,{children:"Incremental builds are possible through a concept known as hashing, where in multiple sources are\naggregated to generate a unique hash. In the context of moon, each time a target is ran we generate\na hash, and if this hash already exists we abort early (cache hit), otherwise we continue the run\n(cache miss)."}),"\n",(0,i.jsxs)(n.p,{children:["The tiniest change may trigger a different hash, for example, changing a line of code (when an\ninput), or updating a package version, so don't worry if you see ",(0,i.jsx)(n.em,{children:"a lot"})," of hashes."]}),"\n",(0,i.jsx)(n.p,{children:"Our smart hashing currently takes the following sources into account:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Command (",(0,i.jsx)(n.code,{children:"command"}),") being ran and its arguments (",(0,i.jsx)(n.code,{children:"args"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Input sources (",(0,i.jsx)(n.code,{children:"inputs"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Output targets (",(0,i.jsx)(n.code,{children:"outputs"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Environment variables (",(0,i.jsx)(n.code,{children:"env"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Dependencies between projects (",(0,i.jsx)(n.code,{children:"dependsOn"}),") and tasks (",(0,i.jsx)(n.code,{children:"deps"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"For Deno tasks"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Deno version."}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"deno.json"}),"/",(0,i.jsx)(n.code,{children:"deps.ts"})," imports, import maps, and scopes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tsconfig.json"})," compiler options (when applicable)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"For Bun and Node.js tasks"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Bun/Node.js version."}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"package.json"})," dependencies (including development and peer)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tsconfig.json"})," compiler options (when applicable)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["Be aware that greedy inputs (",(0,i.jsx)(n.code,{children:"**/*"}),", the default) will include ",(0,i.jsx)(n.em,{children:"everything"})," in the target directory\nas a source. We do our best to filter out VCS ignored files, and ",(0,i.jsx)(n.code,{children:"outputs"})," for the current task, but\nfiles may slip through that you don't expect. We suggest using explicit ",(0,i.jsx)(n.code,{children:"inputs"})," and routinely\nauditing the hash files for accuracy!"]})}),"\n",(0,i.jsx)(n.h2,{id:"archiving--hydration",children:"Archiving & hydration"}),"\n",(0,i.jsxs)(n.p,{children:["On top of our hashing layer, we have another concept known as archiving, where in we create a\ntarball archive of a task's outputs and store it in ",(0,i.jsx)(n.code,{children:".moon/cache/outputs"}),". These are akin to build\nartifacts."]}),"\n",(0,i.jsx)(n.p,{children:"When we encounter a cache hit on a hash, we trigger a mechanism known as hydration, where we\nefficiently unpack an existing tarball archive into a task's outputs. This can be understood as a\ntimeline, where every point in time will have its own hash + archive that moon can play back."}),"\n",(0,i.jsx)(n.p,{children:'Furthermore, if we receive a cache hit on the hash, and the hash is the same as the last run, and\noutputs exist, we exit early without hydrating and assume the project is already hydrated. In the\nterminal, you\'ll see a message for "cached".'}),"\n",(0,i.jsx)(n.h2,{id:"file-structure",children:"File structure"}),"\n",(0,i.jsx)(n.p,{children:"The following diagram outlines our cache folder structure and why each piece exists."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:".moon/cache/\n\t# Stores hash manifests of every ran task. Exists purely for debugging purposes.\n\thashes/\n\t\t# Contents includes all sources used to generate the hash.\n\t\t<hash>.json\n\n\t# Stores `tar.gz` archives of a task's outputs based on its generated hash.\n\toutputs/\n\t\t<hash>.tar.gz\n\n\t# State information about anything and everything within moon. Toolchain,\n\t# dependencies, projects, running targets, etc.\n\tstates/\n\t\t# Files at the root pertain to the entire workspace.\n\t\t<state>.json\n\n\t\t# Files for a project are nested within a folder by the project name.\n\t\t<project>/\n\t\t\t# Informational snapshot of the project, its tasks, and its configs.\n\t\t\t# Can be used at runtime by tasks that require this information.\n\t\t\tsnapshot.json\n\n\t\t\t<task>/\n\t\t\t\t# Contents of the child process, including the exit code and\n\t\t\t\t# unique hash that is referenced above.\n\t\t\t\tlastRun.json\n\n\t\t\t\t# Outputs of last run target.\n\t\t\t\tstderr.log\n\t\t\t\tstdout.log\n"})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);